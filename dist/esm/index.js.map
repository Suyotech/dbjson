{
  "version": 3,
  "sources": ["../../src/schema.mjs", "../../src/model.mjs"],
  "sourcesContent": ["/**\r\n * Class representing a Schema for data validation.\r\n */\r\nclass Schema {\r\n    /**\r\n     * Create a schema.\r\n     * @param {Object} schemaObject - The schema object defining structure of documents.\r\n     */\r\n    constructor(schemaObject) {\r\n      this.#schema = schemaObject;\r\n      \r\n    }\r\n  \r\n    #schema = null;\r\n  \r\n    properties(){\r\n      return Object.keys(Object)\r\n    }\r\n  \r\n    /**\r\n     * Validate if an object matches the schema.\r\n     * @param {Object} obj - The object to validate.\r\n     * @returns {void} - throw error.\r\n     */\r\n    validate(data) {\r\n      const schema = this.#schema;\r\n      if (!data || !schema) {\r\n        throw new Error(\"Data and schema are required for validation.\");\r\n      }\r\n  \r\n      for (const key in schema) {\r\n        const {\r\n          type: expectedType,\r\n          required,\r\n          default: defaultValue,\r\n        } = schema[key];\r\n        let value = data[key];\r\n  \r\n        if (required && (value === undefined || value === null)) {\r\n          if (defaultValue !== undefined) {\r\n            data[key] = defaultValue;\r\n          } else {\r\n            throw new Error(`Required field '${key}' is missing`);\r\n          }\r\n        }\r\n  \r\n        if (required && expectedType === String && value === \"\") {\r\n          throw new Error(`Required field '${key}' cannot be empty`);\r\n        } else if (!required && value === \"\") {\r\n          value = undefined;\r\n        }\r\n  \r\n        // Type validation\r\n        switch (expectedType) {\r\n          case String:\r\n            if (value !== undefined && typeof value !== \"string\") {\r\n              throw new Error(`Invalid type at '${key}'. Expected String.`);\r\n            }\r\n            break;\r\n          case Number:\r\n            if (value !== undefined && typeof value !== \"number\") {\r\n              throw new Error(`Invalid type at '${key}'. Expected Number.`);\r\n            }\r\n            break;\r\n          case Boolean:\r\n            if (value !== undefined && typeof value !== \"boolean\") {\r\n              throw new Error(`Invalid type at '${key}'. Expected Boolean.`);\r\n            }\r\n            break;\r\n          case Object:\r\n            if (\r\n              value !== undefined &&\r\n              (typeof value !== \"object\" || Array.isArray(value))\r\n            ) {\r\n              throw new Error(`Invalid type at '${key}'. Expected Object.`);\r\n            }\r\n            break;\r\n          case Array:\r\n            if (value !== undefined && !Array.isArray(value)) {\r\n              throw new Error(`Invalid type at '${key}'. Expected Array.`);\r\n            }\r\n            break;\r\n          case Date:\r\n            if (value !== undefined) {\r\n              value = new Date(value); // Attempt to parse date\r\n              if (isNaN(value.getTime())) {\r\n                throw new Error(`Invalid date format at '${key}'.`);\r\n              }\r\n              data[key] = value; // Set parsed date\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error(`Unsupported type at '${key}'.`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  export default Schema", "\r\n\r\nclass Model {\r\n    /**\r\n     * Constructs a new Model instance.\r\n     * @param {string} filename - The name of the file to store data.\r\n     * @param {string} dbpath - The db path to store data.\r\n     * @param {Schema} schema - The Schema object for document validation.\r\n     */\r\n    constructor(name, dbpath, schema) {\r\n      if (!name || !dbpath || !(schema instanceof Schema) || !schema) {\r\n        throw new Error(\"Invalid schema or collection name\");\r\n      }\r\n  \r\n      this.#filepath = path.join(dbpath, `${name}.json`);\r\n      this.#schema = schema;\r\n      this.#initialize();\r\n    }\r\n  \r\n    #schema = null;\r\n    #filepath = null;\r\n  \r\n    /**\r\n     * Initialize the collection: create file if not exists.\r\n     */\r\n    #initialize() {\r\n      if (!fs.existsSync(this.#filepath)) {\r\n        fs.writeFileSync(this.#filepath, JSON.stringify([]), \"utf-8\");\r\n      }\r\n  \r\n      const sc = this.#schema\r\n    }\r\n  \r\n    /**\r\n     * reading data from file\r\n     */\r\n    #readFile() {\r\n      return JSON.parse(fs.readFileSync(this.#filepath, \"utf-8\"));\r\n    }\r\n  \r\n    #writeFile(data) {\r\n      fs.writeFileSync(this.#filepath, JSON.stringify(data), \"utf-8\");\r\n    }\r\n  \r\n    /**\r\n     * Creates a new document in the model.\r\n     * @param {Object} obj - The object representing the document to be created.\r\n     * @returns {Object} The created document object.\r\n     * @throws {Error} If validation fails or there is an error during file write.\r\n     */\r\n    createOne(obj) {\r\n      try {\r\n        this.#schema.validate(obj); // Validate object against schema\r\n        const data = this.#readFile();\r\n        obj.id = crypto.randomUUID();\r\n        data.push(obj);\r\n        this.#writeFile(data);\r\n        return obj;\r\n      } catch (error) {\r\n        console.error(\"Error creating document:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Inserts multiple documents into the model.\r\n     * @param {Array<Object>} objs - An array of objects representing the documents to be inserted.\r\n     * @returns {Array<Object>} The array of inserted document objects.\r\n     * @throws {Error} If validation fails or there is an error during file write.\r\n     */\r\n    insertMany(objs) {\r\n      try {\r\n        objs.forEach((obj) => this.#schema.validate(obj)); // Validate objects against schema\r\n        objs.forEach(obj=>obj.id = obj.id = crypto.randomUUID())\r\n        const data = this.#readFile();\r\n        data.push(...objs);\r\n        this.#writeFile(data);\r\n        return objs;\r\n      } catch (error) {\r\n        console.error(\"Error inserting documents:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Finds documents in the model matching the provided query.\r\n     * @param {Object} query - The query object to filter documents.\r\n     * @returns {Operate} The array of documents matching the query.\r\n     * @throws {Error} If there is an error during file read.\r\n     */\r\n    find(query) {\r\n      try {\r\n        const data = this.#readFile();\r\n        const outputdata =  data.filter((entry) => this.#matchesQuery(entry, query));\r\n        return new Operate(outputdata,this.#schema)\r\n      } catch (error) {\r\n        console.error(\"Error finding documents:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Finds a single document in the model matching the provided query.\r\n     * @param {Object} query - The query object to find a document.\r\n     * @returns {Object|null} The document object matching the query, or null if not found.\r\n     * @throws {Error} If there is an error during file read.\r\n     */\r\n    findOne(query) {\r\n      try {\r\n        const data = this.#readFile();\r\n        return data.find((entry) => this.#matchesQuery(entry, query)) || null;\r\n      } catch (error) {\r\n        console.error(\"Error finding document:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  \r\n   /**\r\n     * Finds and deletes a single document in the model matching the provided query.\r\n     * @param {Object} query - The query object to find and delete a document.\r\n     * @returns {Object} The deleted document object.\r\n     * @throws {Error} If the document is not found or there is an error during file read/write.\r\n     */\r\n    findAndDeleteOne(query) {\r\n      try {\r\n        const data = this.#readFile();\r\n        const index = data.findIndex((entry) => this.#matchesQuery(entry, query));\r\n        if (index !== -1) {\r\n          const deletedDocument = data.splice(index, 1)[0];\r\n          this.#writeFile(data);\r\n          return deletedDocument;\r\n        }\r\n        throw new Error(\"Document not found\");\r\n      } catch (error) {\r\n        console.error(\"Error finding and deleting document:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  \r\n      /**\r\n     * Finds and updates a single document in the model matching the provided query.\r\n     * @param {Object} query - The query object to find a document.\r\n     * @param {Object} update - The update object containing fields to update.\r\n     * @returns {Object} The updated document object.\r\n     * @throws {Error} If the document is not found or there is an error during file read/write.\r\n     */\r\n    findOneAndUpdate(query, update) {\r\n      try {\r\n        const data = this.#readFile();\r\n        let updatedDocument = null;\r\n  \r\n        const newData = data.map((entry) => {\r\n          if (this.#matchesQuery(entry, query)) {\r\n            const updatedEntry = { ...entry, ...update };\r\n            updatedDocument = updatedEntry;\r\n            return updatedEntry;\r\n          }\r\n          return entry;\r\n        });\r\n  \r\n        if (updatedDocument) {\r\n          this.#writeFile(newData);\r\n          return updatedDocument;\r\n        } else {\r\n          throw new Error(\"Document not found\");\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error finding and updating document:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Updates multiple documents in the model matching the provided query.\r\n     * @param {Object} query - The query object to filter documents.\r\n     * @param {Object} update - The update object containing fields to update.\r\n     * @returns {Array<Object>} The array of updated document objects.\r\n     * @throws {Error} If there is an error during file read/write.\r\n     */\r\n    updateMany(query, update) {\r\n      try {\r\n        const data = this.#readFile();\r\n        const updatedData = data.map((entry) => {\r\n          if (this.#matchesQuery(entry, query)) {\r\n            return { ...entry, ...update };\r\n          }\r\n          return entry;\r\n        });\r\n  \r\n        this.#writeFile(updatedData);\r\n        return updatedData;\r\n      } catch (error) {\r\n        console.error(\"Error updating documents:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  \r\n     /**\r\n     * Deletes multiple documents in the model matching the provided query.\r\n     * @param {Object} query - The query object to filter documents for deletion.\r\n     * @returns {Array<Object>} The array of remaining document objects after deletion.\r\n     * @throws {Error} If there is an error during file read/write.\r\n     */\r\n    deleteMany(query) {\r\n      try {\r\n        const data = this.#readFile();\r\n        const newData = data.filter((entry) => !this.#matchesQuery(entry, query));\r\n        this.#writeFile(newData);\r\n        return newData;\r\n      } catch (error) {\r\n        console.error(\"Error deleting documents:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  \r\n     /**\r\n     * Helper method to check if an entry matches the provided query, including query operators.\r\n     * @private\r\n     * @param {Object} entry - The entry object from the data array.\r\n     * @param {Object} query - The query object to match against the entry.\r\n     * @returns {boolean} True if the entry matches the query, false otherwise.\r\n     */\r\n    #matchesQuery(entry, query) {\r\n      for (let key in query) {\r\n        const queryValue = query[key];\r\n        const entryValue = entry[key];\r\n  \r\n        if (typeof queryValue === \"object\" && queryValue !== null) {\r\n          // Handle query operators ($in, $nin, $lte, $gte, $eq, $ne)\r\n          for (let operator in queryValue) {\r\n            switch (operator) {\r\n              case \"$in\":\r\n                if (!queryValue.$in.includes(entryValue)) {\r\n                  return false;\r\n                }\r\n                break;\r\n              case \"$nin\":\r\n                if (queryValue.$nin.includes(entryValue)) {\r\n                  return false;\r\n                }\r\n                break;\r\n              case \"$lte\":\r\n                if (entryValue > queryValue.$lte) {\r\n                  return false;\r\n                }\r\n                break;\r\n              case \"$gte\":\r\n                if (entryValue < queryValue.$gte) {\r\n                  return false;\r\n                }\r\n                break;\r\n              case \"$eq\":\r\n                if (entryValue !== queryValue.$eq) {\r\n                  return false;\r\n                }\r\n                break;\r\n              case \"$ne\":\r\n                if (entryValue === queryValue.$ne) {\r\n                  return false;\r\n                }\r\n                break;\r\n              default:\r\n                // Unsupported operator\r\n                return false;\r\n            }\r\n          }\r\n        } else {\r\n          // Regular equality check\r\n          if (queryValue !== entryValue) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Operate class for manipulating data based on schema and operations.\r\n   */\r\n  class Operate {\r\n    /**\r\n     * Creates an instance of Operate.\r\n     * @param {Array} data - The array of data to operate on.\r\n     * @param {Schema} schema - The schema object defining allowed keys and their types.\r\n     */\r\n    constructor(data, schema) {\r\n      /**\r\n       * @type {Array} data - The array of data to operate on.\r\n       */\r\n      this.data = data;\r\n      /**\r\n       * @type {Schema} schema - The schema object defining allowed keys and their types.\r\n       */\r\n      this.schema = schema;\r\n  \r\n      console.log(\"schema value\",this.schema);\r\n      this.#check();\r\n    }\r\n  \r\n    /**\r\n     * Private method to check if data is an array and validate against schema.\r\n     * @private\r\n     */\r\n    #check() {\r\n      if (!Array.isArray(this.data)) {\r\n        throw new Error(\"Invalid data for operation\");\r\n      }\r\n  \r\n      // Validate each object in data against the schema\r\n      this.data.forEach(obj => this.validateObject(obj));\r\n    }\r\n  \r\n    /**\r\n     * Validates an object against the schema.\r\n     * Throws an error if the object does not match the schema.\r\n     * @param {Object} obj - The object to validate.\r\n     * @throws {Error} - Throws error if object does not match schema.\r\n     */\r\n    validateObject(obj) {\r\n      for (let key in this.schema) {\r\n        const { type, required, default: defaultValue } = this.schema[key];\r\n  \r\n        if (required && !obj.hasOwnProperty(key)) {\r\n          throw new Error(`Missing required property \"${key}\"`);\r\n        }\r\n  \r\n        if (obj.hasOwnProperty(key)) {\r\n          if (typeof obj[key] !== type.name.toLowerCase()) {\r\n            throw new Error(`Invalid type for property \"${key}\". Expected ${type.name}`);\r\n          }\r\n        } else if (defaultValue !== undefined) {\r\n          obj[key] = defaultValue;\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Sorts the data array based on the provided sort criteria.\r\n     * @param {Object} sortObj - Object defining sorting criteria { field1: 1, field2: -1 }.\r\n     * @returns {Operate} - Returns the instance of Operate for method chaining.\r\n     * @throws {Error} - Throws error if sort key or operator is invalid.\r\n     */\r\n    sort(sortObj) {\r\n      if (this.data.length === 0) {\r\n        return this; // No sorting needed if data is empty\r\n      }\r\n      for (let key in sortObj) {\r\n        // if (!this.schema.hasOwnProperty(key)) {\r\n        //   throw new Error(`Invalid sort key \"${key}\"`);\r\n        // }\r\n  \r\n        const sortOperator = sortObj[key];\r\n        if (sortOperator !== 1 && sortOperator !== -1) {\r\n          throw new Error(`Invalid sort operator \"${sortOperator}\" for key \"${key}\". Use 1 for ascending, -1 for descending.`);\r\n        }\r\n  \r\n        this.data.sort((a, b) => {\r\n          if (sortOperator === 1) {\r\n            return a[key] - b[key];\r\n          } else if (sortOperator === -1) {\r\n            return b[key] - a[key];\r\n          }\r\n          return 0;\r\n        });\r\n      }\r\n  \r\n      return this;\r\n    }\r\n  \r\n    /**\r\n     * Limits the number of elements in the data array.\r\n     * @param {number} number - Maximum number of elements to keep.\r\n     * @returns {Operate} - Returns the instance of Operate for method chaining.\r\n     */\r\n    limit(number) {\r\n      this.data = this.data.slice(0, number);\r\n      return this;\r\n    }\r\n  \r\n    /**\r\n     * Skips a number of elements from the beginning of the data array.\r\n     * @param {number} number - Number of elements to skip.\r\n     * @returns {Operate} - Returns the instance of Operate for method chaining.\r\n     */\r\n    skip(number) {\r\n      this.data = this.data.slice(number);\r\n      return this;\r\n    }\r\n  \r\n    /**\r\n     * Selects fields from the data array based on the provided selection criteria.\r\n     * @param {Object} selectObj - Object defining fields to include/exclude { field1: 1, field2: 0 }.\r\n     * @returns {Operate} - Returns the instance of Operate for method chaining.\r\n     * @throws {Error} - Throws error if select key is invalid.\r\n     */\r\n    select(selectObj) {\r\n      const keysToShow = Object.keys(selectObj).filter(key => selectObj[key] === 1);\r\n      const keysToHide = Object.keys(selectObj).filter(key => selectObj[key] === 0);\r\n  \r\n      if (keysToShow.length === 0) {\r\n          // If no keys to show, hide all specified keys or all keys if none specified to show\r\n          this.data = this.data.map(obj => {\r\n              const newObj = {};\r\n              for (let key in obj) {\r\n                  if (!selectObj.hasOwnProperty(key) || selectObj[key] === 1) {\r\n                      newObj[key] = obj[key];\r\n                  }\r\n              }\r\n              return newObj;\r\n          });\r\n      } else {\r\n          // Show only selected keys\r\n          this.data = this.data.map(obj => {\r\n              const newObj = {};\r\n              keysToShow.forEach(key => {\r\n                  if (obj.hasOwnProperty(key)) {\r\n                      newObj[key] = obj[key];\r\n                  }\r\n              });\r\n              return newObj;\r\n          });\r\n      }\r\n  \r\n      // Hide specified keys with value 0 from all objects\r\n      keysToHide.forEach(key => {\r\n          this.data.forEach(obj => {\r\n              delete obj[key];\r\n          });\r\n      });\r\n  \r\n      return this;\r\n  }\r\n  \r\n     /**\r\n     * Removes duplicate values from the data array based on a specified key.\r\n     * @param {string} key - The key to check for duplicates.\r\n     * @returns {Operate} - Returns the instance of Operate for method chaining.\r\n     */\r\n     distinct(key) {\r\n      const distinct = new Set();\r\n      this.data.forEach(obj=>{\r\n        const value = obj[key];\r\n        if(value){\r\n          distinct.add(obj[key])\r\n        }\r\n       \r\n      })\r\n  \r\n      this.data = Array.from(distinct)\r\n      return this;\r\n    }\r\n  \r\n    count(){\r\n      this.data = this.data.length\r\n      return this\r\n    }\r\n  \r\n    /**\r\n     * Executes the operations and returns the processed data array.\r\n     * @returns {Array} - The processed data array after all operations.\r\n     */\r\n    exec() {\r\n      return this.data;\r\n    }\r\n  }\r\n\r\n  export default Model"],
  "mappings": "AAGA,IAAMA,EAAN,KAAa,CAKT,YAAYC,EAAc,CACxB,KAAKC,GAAUD,CAEjB,CAEAC,GAAU,KAEV,YAAY,CACV,OAAO,OAAO,KAAK,MAAM,CAC3B,CAOA,SAASC,EAAM,CACb,IAAMC,EAAS,KAAKF,GACpB,GAAI,CAACC,GAAQ,CAACC,EACZ,MAAM,IAAI,MAAM,8CAA8C,EAGhE,QAAWC,KAAOD,EAAQ,CACxB,GAAM,CACJ,KAAME,EACN,SAAAC,EACA,QAASC,CACX,EAAIJ,EAAOC,CAAG,EACVI,EAAQN,EAAKE,CAAG,EAEpB,GAAIE,GAAoCE,GAAU,KAChD,GAAID,IAAiB,OACnBL,EAAKE,CAAG,EAAIG,MAEZ,OAAM,IAAI,MAAM,mBAAmBH,CAAG,cAAc,EAIxD,GAAIE,GAAYD,IAAiB,QAAUG,IAAU,GACnD,MAAM,IAAI,MAAM,mBAAmBJ,CAAG,mBAAmB,EAM3D,OALW,CAACE,GAAYE,IAAU,KAChCA,EAAQ,QAIFH,EAAc,CACpB,KAAK,OACH,GAAIG,IAAU,QAAa,OAAOA,GAAU,SAC1C,MAAM,IAAI,MAAM,oBAAoBJ,CAAG,qBAAqB,EAE9D,MACF,KAAK,OACH,GAAII,IAAU,QAAa,OAAOA,GAAU,SAC1C,MAAM,IAAI,MAAM,oBAAoBJ,CAAG,qBAAqB,EAE9D,MACF,KAAK,QACH,GAAII,IAAU,QAAa,OAAOA,GAAU,UAC1C,MAAM,IAAI,MAAM,oBAAoBJ,CAAG,sBAAsB,EAE/D,MACF,KAAK,OACH,GACEI,IAAU,SACT,OAAOA,GAAU,UAAY,MAAM,QAAQA,CAAK,GAEjD,MAAM,IAAI,MAAM,oBAAoBJ,CAAG,qBAAqB,EAE9D,MACF,KAAK,MACH,GAAII,IAAU,QAAa,CAAC,MAAM,QAAQA,CAAK,EAC7C,MAAM,IAAI,MAAM,oBAAoBJ,CAAG,oBAAoB,EAE7D,MACF,KAAK,KACH,GAAII,IAAU,OAAW,CAEvB,GADAA,EAAQ,IAAI,KAAKA,CAAK,EAClB,MAAMA,EAAM,QAAQ,CAAC,EACvB,MAAM,IAAI,MAAM,2BAA2BJ,CAAG,IAAI,EAEpDF,EAAKE,CAAG,EAAII,CACd,CACA,MACF,QACE,MAAM,IAAI,MAAM,wBAAwBJ,CAAG,IAAI,CACnD,CACF,CACF,CACF,EAEOK,EAAQV,EChGjB,IAAMW,EAAN,KAAY,CAOR,YAAYC,EAAMC,EAAQC,EAAQ,CAChC,GAAI,CAACF,GAAQ,CAACC,GAAU,EAAEC,aAAkB,SAAW,CAACA,EACtD,MAAM,IAAI,MAAM,mCAAmC,EAGrD,KAAKC,GAAY,KAAK,KAAKF,EAAQ,GAAGD,CAAI,OAAO,EACjD,KAAKI,GAAUF,EACf,KAAKG,GAAY,CACnB,CAEAD,GAAU,KACVD,GAAY,KAKZE,IAAc,CACP,GAAG,WAAW,KAAKF,EAAS,GAC/B,GAAG,cAAc,KAAKA,GAAW,KAAK,UAAU,CAAC,CAAC,EAAG,OAAO,EAG9D,IAAMG,EAAK,KAAKF,EAClB,CAKAG,IAAY,CACV,OAAO,KAAK,MAAM,GAAG,aAAa,KAAKJ,GAAW,OAAO,CAAC,CAC5D,CAEAK,GAAWC,EAAM,CACf,GAAG,cAAc,KAAKN,GAAW,KAAK,UAAUM,CAAI,EAAG,OAAO,CAChE,CAQA,UAAUC,EAAK,CACb,GAAI,CACF,KAAKN,GAAQ,SAASM,CAAG,EACzB,IAAMD,EAAO,KAAKF,GAAU,EAC5B,OAAAG,EAAI,GAAK,OAAO,WAAW,EAC3BD,EAAK,KAAKC,CAAG,EACb,KAAKF,GAAWC,CAAI,EACbC,CACT,OAASC,EAAO,CACd,cAAQ,MAAM,2BAA4BA,CAAK,EACzCA,CACR,CACF,CAQA,WAAWC,EAAM,CACf,GAAI,CACFA,EAAK,QAASF,GAAQ,KAAKN,GAAQ,SAASM,CAAG,CAAC,EAChDE,EAAK,QAAQF,GAAKA,EAAI,GAAKA,EAAI,GAAK,OAAO,WAAW,CAAC,EACvD,IAAMD,EAAO,KAAKF,GAAU,EAC5B,OAAAE,EAAK,KAAK,GAAGG,CAAI,EACjB,KAAKJ,GAAWC,CAAI,EACbG,CACT,OAASD,EAAO,CACd,cAAQ,MAAM,6BAA8BA,CAAK,EAC3CA,CACR,CACF,CAQA,KAAKE,EAAO,CACV,GAAI,CAEF,IAAMC,EADO,KAAKP,GAAU,EACH,OAAQQ,GAAU,KAAKC,GAAcD,EAAOF,CAAK,CAAC,EAC3E,OAAO,IAAII,EAAQH,EAAW,KAAKV,EAAO,CAC5C,OAASO,EAAO,CACd,cAAQ,MAAM,2BAA4BA,CAAK,EACzCA,CACR,CACF,CAQA,QAAQE,EAAO,CACb,GAAI,CAEF,OADa,KAAKN,GAAU,EAChB,KAAMQ,GAAU,KAAKC,GAAcD,EAAOF,CAAK,CAAC,GAAK,IACnE,OAASF,EAAO,CACd,cAAQ,MAAM,0BAA2BA,CAAK,EACxCA,CACR,CACF,CAQA,iBAAiBE,EAAO,CACtB,GAAI,CACF,IAAMJ,EAAO,KAAKF,GAAU,EACtBW,EAAQT,EAAK,UAAWM,GAAU,KAAKC,GAAcD,EAAOF,CAAK,CAAC,EACxE,GAAIK,IAAU,GAAI,CAChB,IAAMC,EAAkBV,EAAK,OAAOS,EAAO,CAAC,EAAE,CAAC,EAC/C,YAAKV,GAAWC,CAAI,EACbU,CACT,CACA,MAAM,IAAI,MAAM,oBAAoB,CACtC,OAASR,EAAO,CACd,cAAQ,MAAM,uCAAwCA,CAAK,EACrDA,CACR,CACF,CASA,iBAAiBE,EAAOO,EAAQ,CAC9B,GAAI,CACF,IAAMX,EAAO,KAAKF,GAAU,EACxBc,EAAkB,KAEhBC,EAAUb,EAAK,IAAKM,GAAU,CAClC,GAAI,KAAKC,GAAcD,EAAOF,CAAK,EAAG,CACpC,IAAMU,EAAe,CAAE,GAAGR,EAAO,GAAGK,CAAO,EAC3C,OAAAC,EAAkBE,EACXA,CACT,CACA,OAAOR,CACT,CAAC,EAED,GAAIM,EACF,YAAKb,GAAWc,CAAO,EAChBD,EAEP,MAAM,IAAI,MAAM,oBAAoB,CAExC,OAASV,EAAO,CACd,cAAQ,MAAM,uCAAwCA,CAAK,EACrDA,CACR,CACF,CASA,WAAWE,EAAOO,EAAQ,CACxB,GAAI,CAEF,IAAMI,EADO,KAAKjB,GAAU,EACH,IAAKQ,GACxB,KAAKC,GAAcD,EAAOF,CAAK,EAC1B,CAAE,GAAGE,EAAO,GAAGK,CAAO,EAExBL,CACR,EAED,YAAKP,GAAWgB,CAAW,EACpBA,CACT,OAASb,EAAO,CACd,cAAQ,MAAM,4BAA6BA,CAAK,EAC1CA,CACR,CACF,CAQA,WAAWE,EAAO,CAChB,GAAI,CAEF,IAAMS,EADO,KAAKf,GAAU,EACP,OAAQQ,GAAU,CAAC,KAAKC,GAAcD,EAAOF,CAAK,CAAC,EACxE,YAAKL,GAAWc,CAAO,EAChBA,CACT,OAASX,EAAO,CACd,cAAQ,MAAM,4BAA6BA,CAAK,EAC1CA,CACR,CACF,CASAK,GAAcD,EAAOF,EAAO,CAC1B,QAASY,KAAOZ,EAAO,CACrB,IAAMa,EAAab,EAAMY,CAAG,EACtBE,EAAaZ,EAAMU,CAAG,EAE5B,GAAI,OAAOC,GAAe,UAAYA,IAAe,KAEnD,QAASE,KAAYF,EACnB,OAAQE,EAAU,CAChB,IAAK,MACH,GAAI,CAACF,EAAW,IAAI,SAASC,CAAU,EACrC,MAAO,GAET,MACF,IAAK,OACH,GAAID,EAAW,KAAK,SAASC,CAAU,EACrC,MAAO,GAET,MACF,IAAK,OACH,GAAIA,EAAaD,EAAW,KAC1B,MAAO,GAET,MACF,IAAK,OACH,GAAIC,EAAaD,EAAW,KAC1B,MAAO,GAET,MACF,IAAK,MACH,GAAIC,IAAeD,EAAW,IAC5B,MAAO,GAET,MACF,IAAK,MACH,GAAIC,IAAeD,EAAW,IAC5B,MAAO,GAET,MACF,QAEE,MAAO,EACX,SAIEA,IAAeC,EACjB,MAAO,EAGb,CACA,MAAO,EACT,CACF,EAKMV,EAAN,KAAc,CAMZ,YAAYR,EAAMP,EAAQ,CAIxB,KAAK,KAAOO,EAIZ,KAAK,OAASP,EAEd,QAAQ,IAAI,eAAe,KAAK,MAAM,EACtC,KAAK2B,GAAO,CACd,CAMAA,IAAS,CACP,GAAI,CAAC,MAAM,QAAQ,KAAK,IAAI,EAC1B,MAAM,IAAI,MAAM,4BAA4B,EAI9C,KAAK,KAAK,QAAQnB,GAAO,KAAK,eAAeA,CAAG,CAAC,CACnD,CAQA,eAAeA,EAAK,CAClB,QAASe,KAAO,KAAK,OAAQ,CAC3B,GAAM,CAAE,KAAAK,EAAM,SAAAC,EAAU,QAASC,CAAa,EAAI,KAAK,OAAOP,CAAG,EAEjE,GAAIM,GAAY,CAACrB,EAAI,eAAee,CAAG,EACrC,MAAM,IAAI,MAAM,8BAA8BA,CAAG,GAAG,EAGtD,GAAIf,EAAI,eAAee,CAAG,GACxB,GAAI,OAAOf,EAAIe,CAAG,IAAMK,EAAK,KAAK,YAAY,EAC5C,MAAM,IAAI,MAAM,8BAA8BL,CAAG,eAAeK,EAAK,IAAI,EAAE,OAEpEE,IAAiB,SAC1BtB,EAAIe,CAAG,EAAIO,EAEf,CACF,CAQA,KAAKC,EAAS,CACZ,GAAI,KAAK,KAAK,SAAW,EACvB,OAAO,KAET,QAASR,KAAOQ,EAAS,CAKvB,IAAMC,EAAeD,EAAQR,CAAG,EAChC,GAAIS,IAAiB,GAAKA,IAAiB,GACzC,MAAM,IAAI,MAAM,0BAA0BA,CAAY,cAAcT,CAAG,4CAA4C,EAGrH,KAAK,KAAK,KAAK,CAACU,EAAGC,IACbF,IAAiB,EACZC,EAAEV,CAAG,EAAIW,EAAEX,CAAG,EACZS,IAAiB,GACnBE,EAAEX,CAAG,EAAIU,EAAEV,CAAG,EAEhB,CACR,CACH,CAEA,OAAO,IACT,CAOA,MAAMY,EAAQ,CACZ,YAAK,KAAO,KAAK,KAAK,MAAM,EAAGA,CAAM,EAC9B,IACT,CAOA,KAAKA,EAAQ,CACX,YAAK,KAAO,KAAK,KAAK,MAAMA,CAAM,EAC3B,IACT,CAQA,OAAOC,EAAW,CAChB,IAAMC,EAAa,OAAO,KAAKD,CAAS,EAAE,OAAOb,GAAOa,EAAUb,CAAG,IAAM,CAAC,EACtEe,EAAa,OAAO,KAAKF,CAAS,EAAE,OAAOb,GAAOa,EAAUb,CAAG,IAAM,CAAC,EAE5E,OAAIc,EAAW,SAAW,EAEtB,KAAK,KAAO,KAAK,KAAK,IAAI7B,GAAO,CAC7B,IAAM+B,EAAS,CAAC,EAChB,QAAShB,KAAOf,GACR,CAAC4B,EAAU,eAAeb,CAAG,GAAKa,EAAUb,CAAG,IAAM,KACrDgB,EAAOhB,CAAG,EAAIf,EAAIe,CAAG,GAG7B,OAAOgB,CACX,CAAC,EAGD,KAAK,KAAO,KAAK,KAAK,IAAI/B,GAAO,CAC7B,IAAM+B,EAAS,CAAC,EAChB,OAAAF,EAAW,QAAQd,GAAO,CAClBf,EAAI,eAAee,CAAG,IACtBgB,EAAOhB,CAAG,EAAIf,EAAIe,CAAG,EAE7B,CAAC,EACMgB,CACX,CAAC,EAILD,EAAW,QAAQf,GAAO,CACtB,KAAK,KAAK,QAAQf,GAAO,CACrB,OAAOA,EAAIe,CAAG,CAClB,CAAC,CACL,CAAC,EAEM,IACX,CAOG,SAASA,EAAK,CACb,IAAMiB,EAAW,IAAI,IACrB,YAAK,KAAK,QAAQhC,GAAK,CACPA,EAAIe,CAAG,GAEnBiB,EAAS,IAAIhC,EAAIe,CAAG,CAAC,CAGzB,CAAC,EAED,KAAK,KAAO,MAAM,KAAKiB,CAAQ,EACxB,IACT,CAEA,OAAO,CACL,YAAK,KAAO,KAAK,KAAK,OACf,IACT,CAMA,MAAO,CACL,OAAO,KAAK,IACd,CACF,EAEOC,EAAQ5C",
  "names": ["Schema", "schemaObject", "#schema", "data", "schema", "key", "expectedType", "required", "defaultValue", "value", "schema_default", "Model", "name", "dbpath", "schema", "#filepath", "#schema", "#initialize", "sc", "#readFile", "#writeFile", "data", "obj", "error", "objs", "query", "outputdata", "entry", "#matchesQuery", "Operate", "index", "deletedDocument", "update", "updatedDocument", "newData", "updatedEntry", "updatedData", "key", "queryValue", "entryValue", "operator", "#check", "type", "required", "defaultValue", "sortObj", "sortOperator", "a", "b", "number", "selectObj", "keysToShow", "keysToHide", "newObj", "distinct", "model_default"]
}
